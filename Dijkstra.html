<html>
  <head>
    <title>Dijkstra's Algorithm demonstration</title>
    <link
      rel="icon"
      type="image/x-icon"
      href="https://upload.wikimedia.org/wikipedia/commons/thumb/2/24/Edsger_Wybe_Dijkstra_%28square%29.jpg/250px-Edsger_Wybe_Dijkstra_%28square%29.jpg"
    />
  </head>
  <body>
    <h1>Dijkstra's algorithm demonstration</h1>

    <img
      width="15%"
      style="float: left"
      src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d9/Edsger_Wybe_Dijkstra.jpg/250px-Edsger_Wybe_Dijkstra.jpg"
    />
    <div style="float: left; padding: 1em">
      Click below to add one or more nodes.<br />
      Click a node to select it, then:
      <ul>
        <li>click another node to create an edge, or</li>
        <li>press "delete" to delete it, or</li>
        <li>press "esc" to cancel the selection</li>
      </ul>
      Click an edge to select it, then:
      <ul>
        <li>edit the weight, or</li>
        <li>press "delete" to delete it, or</li>
        <li>press "esc" to cancel the selection</li>
      </ul>
    </div>
    <button onclick="stepDijkstra()">Step Dijkstra's Algorithm</button>
    <button onclick="resetDijkstra()">Reset steps</button>
    <button onclick="runDijkstra()">Run Dijkstra's Algorithm to end</button>
    <div>
      <h2>Shortest paths from first to each other node</h2>
      <p id="output"></p>
      <h2>Min-Heap</h2>
      <p id="heap"></p>
    </div>

    <script src="graph.js"></script>
    <script>
      class MinHeap {
        constructor() {
          this.heap = [];
        }

        // Insert a new item into the min-heap
        push(item) {
          this.heap.push(item);
          this._bubbleUp(this.heap.length - 1);
        }

        // Remove and return the smallest item from the min-heap
        pop() {
          if (this.heap.length === 0) return null;
          const min = this.heap[0];
          const last = this.heap.pop();
          if (this.heap.length > 0) {
            this.heap[0] = last;
            this._bubbleDown(0);
          }
          return min;
        }

        // Bubble up the item at index i to maintain the heap property
        _bubbleUp(i) {
          const item = this.heap[i];
          while (i > 0) {
            const parent = Math.floor((i - 1) / 2);
            if (this.heap[parent].distance <= item.distance) break;
            this.heap[i] = this.heap[parent];
            i = parent;
          }
          this.heap[i] = item;
        }

        // Bubble down the item at index i to maintain the heap property
        _bubbleDown(i) {
          const item = this.heap[i];
          const length = this.heap.length;
          while (true) {
            const left = 2 * i + 1;
            const right = 2 * i + 2;
            let smallest = i;
            if (
              left < length &&
              this.heap[left].distance < this.heap[smallest].distance
            ) {
              smallest = left;
            }
            if (
              right < length &&
              this.heap[right].distance < this.heap[smallest].distance
            ) {
              smallest = right;
            }
            if (smallest === i) break;
            this.heap[i] = this.heap[smallest];
            i = smallest;
          }
          this.heap[i] = item;
        }

        get length() {
          return this.heap.length;
        }

        get values() {
          return this.heap;
        }

        clear() {
          this.heap = [];
        }
      }

      const output = $("#output");
      const heapOutput = $("#heap");
      const distances = new Map(); // Map to store distances from the first node
      const adjList = new Map(); // Adjacency list for the graph
      const heap = new MinHeap();

      let stepping = false; // Flag to indicate if stepping is active

      // Setup function to initialize the algorithm
      const setup = () => {
        stepping = false; // Reset stepping flag
        output.innerHTML = ""; // Clear previous output
        heapOutput.innerHTML = ""; // Clear previous heap output
        distances.clear();
        adjList.clear();
        heap.clear();
        if (nodes.length === 0) {
          output.innerText = "Make some nodes first.";
          return;
        }
        const table = document.createElement("table");
        table.setAttribute("border", "1");
        output.appendChild(table);
        const headerRow = document.createElement("tr");
        const dataRow = document.createElement("tr");
        nodes.forEach((node) => {
          const header = document.createElement("th");
          header.innerText = node.id;
          headerRow.appendChild(header);
          distances.set(node.id, Infinity); // Initialize distances to Infinity
          const cell = document.createElement("td");
          cell.setAttribute("id", "D" + node.id);
          dataRow.appendChild(cell);
        });
        distances.set(nodes[0].id, 0); // Distance to the start node is 0
        table.appendChild(headerRow);
        table.appendChild(dataRow);
        displayDistances();
        nodes.forEach((node, index) => {
          adjList.set(node.id, []);
        });
        edges.forEach((edge) => {
          adjList
            .get(edge.start.id)
            .push({ node: edge.end, weight: edge.weight });
          adjList
            .get(edge.end.id)
            .push({ node: edge.start, weight: edge.weight });
        });
        heap.push({ node: nodes[0], distance: 0 });
        displayHeap();
      };

      const displayDistances = () => {
        nodes.forEach((node) => {
          const cell = $("#D" + node.id);
          if (!cell) return; // In case some clever person adds a node between steps.
          const dist = distances.get(node.id);
          cell.innerText = dist === Infinity ? "âˆž" : dist.toFixed(2);
        });
      };

      const displayHeap = () => {
        heapOutput.innerHTML = ""; // Clear previous heap output
        if (heap.length === 0) {
          heapOutput.innerText = "Heap is empty.";
          return;
        }
        const ul = document.createElement("ul");
        heap.values.forEach((item) => {
          const li = document.createElement("li");
          li.innerText = `Node: ${item.node.id}, Distance: ${item.distance}`;
          ul.appendChild(li);
        });
        heapOutput.appendChild(ul);
      };

      const setUpDataStructures = () => {
        distances.clear();
        nodes.forEach((node) => {
          distances.set(node.id, Infinity); // Initialize distances to Infinity
        });
        distances.set(nodes[0].id, 0); // Distance to the start node is 0
      };

      const runDijkstra = () => {
        setup();
        while (heap.length > 0) {
          const { node, distance } = heap.pop();
          adjList.get(node.id).forEach(({ node: neighbor, weight }) => {
            const newDist = distance + weight;
            if (newDist < distances.get(neighbor.id)) {
              distances.set(neighbor.id, newDist);
              heap.push({ node: neighbor, distance: newDist });
            }
          });
        }
        displayDistances();
        displayHeap();
      };

      const resetDijkstra = () => {
        setup();
        stepping = true; // Ready stepping flag
      };

      const stepDijkstra = () => {
        if (!stepping) {
          resetDijkstra();
          return;
        }
        if (heap.length > 0) {
          const { node, distance } = heap.pop();
          adjList.get(node.id).forEach(({ node: neighbor, weight }) => {
            const newDist = distance + weight;
            if (newDist < distances.get(neighbor.id)) {
              distances.set(neighbor.id, newDist);
              heap.push({ node: neighbor, distance: newDist });
            }
          });
        }
        displayDistances();
        displayHeap();
      };
    </script>
  </body>
</html>
